import React, { useEffect, useState } from 'react';
import { Box, Typography } from '@mui/material';
import { fetchDvrs, createDvr, deleteDvr, createRegistro } from '../services/apiService';
import ProfileSidebar from './ProfileSidebar';
import CameraTable from './CameraTable';
import Swal from 'sweetalert2';
import '../styles/CameraControlSystem.css';  // Importamos el archivo CSS
import imagenBienvenida from '../assets/imagenBienvenida-removebg.png'; // Asegúrate de tener esta imagen en la carpeta correcta

const CameraControlSystem = () => {
  const [dvrs, setDvrs] = useState([]);
  const [showCameraControl, setShowCameraControl] = useState(false);

  useEffect(() => {
    const loadData = async () => {
      try {
        const dvrsData = await fetchDvrs();
        setDvrs(dvrsData.map(dvr => ({
          ...dvr,
          diasGrabacion: '',
          verificacionAM: false,
          verificacionPM: false,
          amDisabled: false,
          pmDisabled: false,
        })));
      } catch (error) {
        console.error('Failed to load DVRs:', error);
      }
    };
    loadData();
  }, []);

  const handleEdit = (id, field, value) => {
    setDvrs(prevDvrs => {
      const updatedDvrs = prevDvrs.map(dvr => {
        if (dvr.id === id) {
          const updatedDvr = { ...dvr, [field]: value };
  
          if (field === 'fechaInicio' || field === 'fechaFinal') {
            const { fechaInicio, fechaFinal } = updatedDvr;
  
            if (fechaInicio && fechaFinal) {
              const startDate = new Date(fechaInicio);
              const endDate = new Date(fechaFinal);
              const daysOfRecording = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;
  
              if (daysOfRecording > 0) {
                updatedDvr.diasGrabacion = daysOfRecording;
              } else {
                updatedDvr.diasGrabacion = 0;
              }
            }
          }
  
          return updatedDvr;
        }
        return dvr;
      });
  
      return updatedDvrs;
    });
  };

  const handleRegister = async (id) => {
    const dvr = dvrs.find(dvr => dvr.id === id);
  
    // Verificar que al menos una verificación esté seleccionada
    if (!dvr.verificacionAM && !dvr.verificacionPM) {
      Swal.fire({
        icon: 'warning',
        title: 'Registro Incompleto',
        text: 'Debe seleccionar al menos una verificación (AM o PM) para registrar.',
      });
      return;
    }
  
    const registroData = {
      dvr: id,
      dias_grabacion: dvr.diasGrabacion,
      verificacion_am: dvr.verificacionAM,
      verificacion_pm: dvr.verificacionPM,
      observacion: dvr.observacion,
      fecha_inicio: dvr.fechaInicio ? new Date(dvr.fechaInicio).toISOString().split('T')[0] : null,
      fecha_final: dvr.fechaFinal ? new Date(dvr.fechaFinal).toISOString().split('T')[0] : null,
    };
  
    try {
      await createRegistro(registroData);
      Swal.fire({
        icon: 'success',
        title: 'Registro Exitoso',
        text: 'El registro se ha creado correctamente.',
      });
  
      if (dvr.verificacionAM) {
        handleEdit(id, 'amDisabled', true);
        handleEdit(id, 'verificacionAM', false);
      }
  
      if (dvr.verificacionPM) {
        handleEdit(id, 'pmDisabled', true);
        handleEdit(id, 'verificacionPM', false);
      }
      
      setDvrs(prevDvrs => [...prevDvrs]);
  
    } catch (error) {
      console.error('Error creando el registro:', error);
      Swal.fire({
        icon: 'error',
        title: 'Error',
        text: 'Hubo un error al crear el registro.',
      });
    }
  };

  const handleCreateDvr = async (newDvrData) => {
    try {
      const newDvr = await createDvr(newDvrData);
      setDvrs([...dvrs, {
        ...newDvr,
        diasGrabacion: '',
        verificacionAM: false,
        verificacionPM: false,
        amDisabled: false,
        pmDisabled: false,
      }]);
    } catch (error) {
      console.error('Error creating DVR:', error);
    }
  };

  const handleDeleteDvr = async (id) => {
    try {
      await deleteDvr(id);
      setDvrs(dvrs.filter(dvr => dvr.id !== id));
    } catch (error) {
      console.error('Error deleting DVR:', error);
    }
  };

  const toggleContentVisibility = () => {
    setShowCameraControl(true);
  };

  const username = localStorage.getItem('username');

  return (
    <Box className="camera-control-system">
      <ProfileSidebar
        username={username}
        handleLogout={() => {
          localStorage.removeItem('uid');
          localStorage.removeItem('username');
          window.location.href = '/';
        }}
        dvrs={dvrs}
        onCreateDvr={handleCreateDvr}
        onDeleteDvr={handleDeleteDvr}
        onShowCameraControl={toggleContentVisibility}
      />

      <Box className="camera-control-content">
        {showCameraControl ? (
          <Box className="camera-table-wrapper">
            <Typography variant="h4" gutterBottom sx={{ color: '#003366', textAlign: 'center' }}>
              Control de Cámaras
            </Typography>
            <CameraTable
              dvrs={dvrs}
              handleEdit={handleEdit}
              handleRegister={handleRegister}
            />
          </Box>
        ) : (
          <Box sx={{ textAlign: 'center', marginTop: '20px' }}>
            <Typography
              variant="h4"
              gutterBottom
              className="welcome-message"
            >
              Bienvenido al Control de Cámaras
            </Typography>

            {/* Aquí colocamos la imagen debajo del título */}
            <img 
              src={imagenBienvenida} 
              alt="Control de Cámaras"
              style={{ width: '400%', maxWidth: '400px', height: 'auto', marginTop: '20px', marginBottom: '20px' }} 
            />
          </Box>
        )}
      </Box>
    </Box>
  );
};

export default CameraControlSystem;

import React from 'react';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../AuthContext'; // Importamos el contexto de autenticación

const ProtectedRoute = ({ children }) => {
  const { authTokens, loading } = useAuth(); // Obtenemos el token de autenticación y el estado de carga

  // Si está en estado de carga (verificando el token), mostrar una pantalla de carga
  if (loading) {
    return <div>Cargando...</div>;
  }

  // Si no hay tokens (usuario no autenticado), redirigir al login
  if (!authTokens) {
    return <Navigate to="/login" />;
  }

  // Si hay tokens, renderizar el contenido protegido
  return children;
};

export default ProtectedRoute;
import axios from 'axios';

const API_URL = 'http://127.0.0.1:8000/api';

// Crea una instancia de Axios para configurar la base URL si es necesario
const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Función para obtener las cámaras de un DVR específico
export const fetchCamarasByDvr = async (dvrId) => {
  try {
    const response = await api.get(`/camaras/?dvr=${dvrId}`);
    return response.data;
  } catch (error) {
    console.error('Error fetching camaras:', error);
    throw error;
  }
};


// Función para obtener la lista de DVRs
export const fetchDvrs = async () => {
  try {
    const response = await api.get('/dvrs/');
    console.log(response);
    return response.data;
  } catch (error) {
    console.error('Error fetching DVRs:', error);
    throw error;
  }
};

// Función para crear un nuevo DVR
export const createDvr = async (dvrData) => {
  try {
    const response = await api.post('/dvrs/', dvrData);
    return response.data;
  } catch (error) {
    console.error('Error creating DVR:', error);
    throw error;
  }
};

// Función para eliminar DVR
export const deleteDvr = async (dvrId) => {
  try {
    await api.delete(`/dvrs/${dvrId}/`);
  } catch (error) {
    console.error('Error deleting DVR:', error);
    throw error;
  }
};

// Función para obtener registros
export const fetchRegistros = async () => {
  try {
    const response = await api.get('/registros/');
    return response.data;
  } catch (error) {
    console.error('Error fetching registros:', error);
    throw error;
  }
};

// Función para crear un registro
export const createRegistro = async (registroData) => {
  try {
    const response = await api.post('/registros/', registroData);
    return response.data;
  } catch (error) {
    console.error('Error creating registro:', error);
    throw error;
  }
};

// Función para obtener la lista de Cámaras
export const fetchCamaras = async () => {
  try {
    const response = await api.get('/camaras/');
    return response.data;
  } catch (error) {
    console.error('Error fetching camaras:', error);
    throw error;
  }
};

// Función para crear una nueva Cámara
export const createCamara = async (camaraData) => {
  try {
    const response = await api.post('/camaras/', camaraData);
    return response.data;
  } catch (error) {
    console.error('Error creating camara:', error);
    throw error;
  }
};

// Función para eliminar una Cámara
export const deleteCamara = async (camaraId) => {
  try {
    await api.delete(`/camaras/${camaraId}/`);
  } catch (error) {
    console.error('Error deleting camara:', error);
    throw error;
  }
};

export default api;
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import Login from './screens/Login';
import CameraControlSystem from './components/home';
import { AuthProvider } from './AuthContext';
import ProtectedRoute from './routes/ProtectedRoute';

const App = () => {
  
  return (
    <AuthProvider>
      <Router>
        <Routes>
          <Route path="/login" element={<Login />} />
          <Route 
            path="/home" 
            element={
              <ProtectedRoute>
                <CameraControlSystem />
              </ProtectedRoute>
            } 
          />
          <Route path="*" element={<Navigate to="/login" />} />
        </Routes>
      </Router>
    </AuthProvider>
  );
};

export default App;
import React, { createContext, useState, useContext, useEffect } from 'react';
import axios from 'axios';
import {jwtDecode} from 'jwt-decode'; // Corregida la importación

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [authTokens, setAuthTokens] = useState(() => localStorage.getItem('tokens') ? JSON.parse(localStorage.getItem('tokens')) : null);
  const [user, setUser] = useState(() => authTokens ? jwtDecode(authTokens.access) : null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (authTokens) {
      try {
        setUser(jwtDecode(authTokens.access)); // Intentamos decodificar el token
      } catch (error) {
        console.error("Token inválido:", error);
        setAuthTokens(null);
        setUser(null); // Si el token es inválido, deslogueamos
        localStorage.removeItem('tokens');
      }
    }
    setLoading(false); // Aseguramos que el estado de loading termine
  }, [authTokens]);

  const login = async (username, password, navigate) => {
    try {
      const response = await axios.post('http://127.0.0.1:8000/api/token/', { username, password });
      setAuthTokens(response.data);
      localStorage.setItem('tokens', JSON.stringify(response.data));
      setUser(jwtDecode(response.data.access));
      navigate('/home');
    } catch (error) {
      console.error('Error al iniciar sesión', error);
    }
  };

  const logout = (navigate) => {
    setAuthTokens(null);
    setUser(null);
    localStorage.removeItem('tokens');
    navigate('/login');
  };

  return (
    <AuthContext.Provider value={{ authTokens, user, login, logout, loading }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext);
import React from 'react';
import { createRoot } from 'react-dom/client';
import AppRoutes from './routes';
import { AuthProvider } from './AuthContext'; // Contexto de autenticación

const container = document.getElementById('root');
const root = createRoot(container);

root.render(
  <AuthProvider>
    <AppRoutes />
  </AuthProvider>
);
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import Login from './screens/Login';
import CameraControlSystem from '../src/components/home';
import ProtectedRoute from './routes/ProtectedRoute';
import { AuthProvider } from './AuthContext';

const AppRoutes = () => {
  return (
    <AuthProvider>
      <Router>
        <Routes>
          <Route path="/login" element={<Login />} />
          <Route 
            path="/home" 
            element={
              <ProtectedRoute>
                <CameraControlSystem/>
              </ProtectedRoute>
            } 
          />
          {/* Redirigir cualquier otra ruta al login */}
          <Route path="*" element={<Navigate to="/login" />} />
        </Routes>
      </Router>
    </AuthProvider>
  );
};

export default AppRoutes;